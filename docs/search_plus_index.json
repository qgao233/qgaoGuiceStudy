{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction guice home Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-25 19:00:00 "},"chapter1/":{"url":"chapter1/","title":"Guice 起因(发音juice)","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 传统的写法 1.1 BillingService 1.2 Factories 1.3 unit test 2 依赖注入 3 Guice里的依赖注入 3.1 AbstractModule 3.2 @Inject 3.3 createInjector Guice 起因 将各个模块连接起来是比较枯燥(tedious)的，用一个使用信用卡支付账单的例子来讲解为何开发Guice框架。 1 传统的写法 1.1 BillingService 在支付账单的service里，直接使用new的方式去获取两个工具类来达到真正地支付的操作： PaypalCreditCardProcessor DatabaseTransactionLog public class RealBillingService implements BillingService { public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) { CreditCardProcessor processor = new PaypalCreditCardProcessor(); TransactionLog transactionLog = new DatabaseTransactionLog(); try { ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); } catch (UnreachableException e) { transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); } } } 1.2 Factories 感觉直接new两个工具类不太好，于是决定用工厂模式替代直接new的方式，并达到解耦(decouple)service和工具类的工作。 下面是根据工厂模式的模板(boilerplate)代码写的： public class CreditCardProcessorFactory { private static CreditCardProcessor instance; public static void setInstance(CreditCardProcessor processor) { instance = processor; } public static CreditCardProcessor getInstance() { if (instance == null) { return new SquareCreditCardProcessor(); } return instance; } } 更新后的service： CreditCardProcessor processor = CreditCardProcessorFactory.getInstance(); TransactionLog transactionLog = TransactionLogFactory.getInstance(); 1.3 unit test 在测试启动关闭时将两个工具类设值或Null，但是这个代码很蠢，因为一个真正的业务factory居然保存了两个用来测试的工具类。 所以我们需要很谨慎地来设置factory里的值，一旦在测试时teardown方法执行失败，那么factory里的两个工具类就会影响到其它依赖该factory的程序。 而且最大的问题是service通过factory依赖的两个工具类是隐藏在代码里面的，对client是完全透明的，一旦我们忘记service里需要依赖这两个工具类，从而不在client里给factory设值，程序就运行崩溃了(attempted)。 public class RealBillingServiceTest extends TestCase { private final PizzaOrder order = new PizzaOrder(100); private final CreditCard creditCard = new CreditCard(\"1234\", 11, 2010); private final InMemoryTransactionLog transactionLog = new InMemoryTransactionLog(); private final FakeCreditCardProcessor processor = new FakeCreditCardProcessor(); @Override public void setUp() { TransactionLogFactory.setInstance(transactionLog); CreditCardProcessorFactory.setInstance(processor); } @Override public void tearDown() { TransactionLogFactory.setInstance(null); CreditCardProcessorFactory.setInstance(null); } public void testSuccessfulCharge() { RealBillingService billingService = new RealBillingService(); Receipt receipt = billingService.chargeOrder(order, creditCard); assertTrue(receipt.hasSuccessfulCharge()); assertEquals(100, receipt.getAmountOfCharge()); assertEquals(creditCard, processor.getCardOfOnlyCharge()); assertEquals(100, processor.getAmountOfOnlyCharge()); assertTrue(transactionLog.wasSuccessLogged()); } } 2 依赖注入 这个设计模式的核心是依赖倒转原则(separate behaviour from dependency resolution)。 依赖倒转原则认为，service不应该负责去寻找到两个具体的工具类，而应该是外部找到注入给service的。 并且注入的方式应该是通过构造方法的方式注入，这样该类需要什么参数，一目了然。 The dependency is exposed in the API signature. 更改service后的代码： public class RealBillingService implements BillingService { private final CreditCardProcessor processor; private final TransactionLog transactionLog; public RealBillingService(CreditCardProcessor processor,TransactionLog transactionLog) { this.processor = processor; this.transactionLog = transactionLog; } public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) { try { ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); } catch (UnreachableException e) { transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); } } } 3 Guice里的依赖注入 Guice框架底层已经把实现搞定，我们需要做的事就是将我们的接口对应到它们的实现。 3.1 AbstractModule 用上面的例子举例，首先得自定义一个Module类去继承Guice提供的AbstractModule。 public class BillingModule extends AbstractModule { @Override protected void configure() { bind(TransactionLog.class).to(DatabaseTransactionLog.class); bind(CreditCardProcessor.class).to(PaypalCreditCardProcessor.class); bind(BillingService.class).to(RealBillingService.class); } } 3.2 @Inject 将注解@Inject放到service的构造方法上，Guice会去它的容器找到构造方法中的参数对应的bean，并设置给构造方法的参数。 public class RealBillingService implements BillingService { private final CreditCardProcessor processor; private final TransactionLog transactionLog; @Inject public RealBillingService(CreditCardProcessor processor, TransactionLog transactionLog) { this.processor = processor; this.transactionLog = transactionLog; } public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) { try { ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); } catch (UnreachableException e) { transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); } } } 3.3 createInjector 用该方法就可以初始化Guice里的容器： public static void main(String[] args) { Injector injector = Guice.createInjector(new BillingModule()); BillingService billingService = injector.getInstance(BillingService.class); ... } 并且使用injector可以从任意类获取到放进Guice中的bean。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-28 19:45:56 "},"chapter2/":{"url":"chapter2/","title":"Guice 快速上手","keywords":"","body":"Guice 快速上手 用一个简单的例子说明， 废话不多说，直接上最终的结果，通过注释轻松上手： import static java.lang.annotation.RetentionPolicy.RUNTIME; import com.google.inject.AbstractModule; import com.google.inject.Guice; import com.google.inject.Injector; import com.google.inject.Key; import com.google.inject.Provides; import java.lang.annotation.Retention; import javax.inject.Inject; import javax.inject.Qualifier; public class GuiceDemo { @Qualifier // javaEE提供的注解 @Retention(RUNTIME) @interface Message {} @Qualifier @Retention(RUNTIME) @interface Count {} /** * 用来绑定message和count的module，会被Greeter类依赖 * 除了下面的注解方法，还可以使用上一节中提到的bind方法进行绑定 */ static class DemoModule extends AbstractModule { @Provides // Guice提供的注解，表示会被放入Guice容器中 @Count // 用来帮助注入时别找错了bean static Integer provideCount() { return 3; } @Provides @Message static String provideMessage() { return \"hello world\"; } } static class Greeter { private final String message; private final int count; // Greeter类的构造方法表示它需要1个String类的参数和1个用来打印消息次数的int类参数 // 而@Inject表示这个构造方法可以被Guice使用 @Inject Greeter(@Message String message, @Count int count) { this.message = message; this.count = count; } void sayHello() { for (int i=0; i Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-28 21:12:31 "}}