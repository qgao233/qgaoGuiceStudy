{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction guice home Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-25 19:00:00 "},"chapter1/":{"url":"chapter1/","title":"Guice 起因(发音juice)","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 传统的写法 1.1 BillingService 1.2 Factories 1.3 unit test 2 依赖注入 3 Guice里的依赖注入 3.1 AbstractModule 3.2 @Inject 3.3 createInjector Guice 起因 将各个模块连接起来是比较枯燥(tedious)的，用一个使用信用卡支付账单的例子来讲解为何开发Guice框架。 1 传统的写法 1.1 BillingService 在支付账单的service里，直接使用new的方式去获取两个工具类来达到真正地支付的操作： PaypalCreditCardProcessor DatabaseTransactionLog public class RealBillingService implements BillingService { public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) { CreditCardProcessor processor = new PaypalCreditCardProcessor(); TransactionLog transactionLog = new DatabaseTransactionLog(); try { ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); } catch (UnreachableException e) { transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); } } } 1.2 Factories 感觉直接new两个工具类不太好，于是决定用工厂模式替代直接new的方式，并达到解耦(decouple)service和工具类的工作。 下面是根据工厂模式的模板(boilerplate)代码写的： public class CreditCardProcessorFactory { private static CreditCardProcessor instance; public static void setInstance(CreditCardProcessor processor) { instance = processor; } public static CreditCardProcessor getInstance() { if (instance == null) { return new SquareCreditCardProcessor(); } return instance; } } 更新后的service： CreditCardProcessor processor = CreditCardProcessorFactory.getInstance(); TransactionLog transactionLog = TransactionLogFactory.getInstance(); 1.3 unit test 在测试启动关闭时将两个工具类设值或Null，但是这个代码很蠢，因为一个真正的业务factory居然保存了两个用来测试的工具类。 所以我们需要很谨慎地来设置factory里的值，一旦在测试时teardown方法执行失败，那么factory里的两个工具类就会影响到其它依赖该factory的程序。 而且最大的问题是service通过factory依赖的两个工具类是隐藏在代码里面的，对client是完全透明的，一旦我们忘记service里需要依赖这两个工具类，从而不在client里给factory设值，程序就运行崩溃了(attempted)。 public class RealBillingServiceTest extends TestCase { private final PizzaOrder order = new PizzaOrder(100); private final CreditCard creditCard = new CreditCard(\"1234\", 11, 2010); private final InMemoryTransactionLog transactionLog = new InMemoryTransactionLog(); private final FakeCreditCardProcessor processor = new FakeCreditCardProcessor(); @Override public void setUp() { TransactionLogFactory.setInstance(transactionLog); CreditCardProcessorFactory.setInstance(processor); } @Override public void tearDown() { TransactionLogFactory.setInstance(null); CreditCardProcessorFactory.setInstance(null); } public void testSuccessfulCharge() { RealBillingService billingService = new RealBillingService(); Receipt receipt = billingService.chargeOrder(order, creditCard); assertTrue(receipt.hasSuccessfulCharge()); assertEquals(100, receipt.getAmountOfCharge()); assertEquals(creditCard, processor.getCardOfOnlyCharge()); assertEquals(100, processor.getAmountOfOnlyCharge()); assertTrue(transactionLog.wasSuccessLogged()); } } 2 依赖注入 这个设计模式的核心是依赖倒转原则(separate behaviour from dependency resolution)。 依赖倒转原则认为，service不应该负责去寻找到两个具体的工具类，而应该是外部找到注入给service的。 并且注入的方式应该是通过构造方法的方式注入，这样该类需要什么参数，一目了然。 The dependency is exposed in the API signature. 更改service后的代码： public class RealBillingService implements BillingService { private final CreditCardProcessor processor; private final TransactionLog transactionLog; public RealBillingService(CreditCardProcessor processor,TransactionLog transactionLog) { this.processor = processor; this.transactionLog = transactionLog; } public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) { try { ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); } catch (UnreachableException e) { transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); } } } 3 Guice里的依赖注入 Guice框架底层已经把实现搞定，我们需要做的事就是将我们的接口对应到它们的实现。 3.1 AbstractModule 用上面的例子举例，首先得自定义一个Module类去继承Guice提供的AbstractModule。 public class BillingModule extends AbstractModule { @Override protected void configure() { bind(TransactionLog.class).to(DatabaseTransactionLog.class); bind(CreditCardProcessor.class).to(PaypalCreditCardProcessor.class); bind(BillingService.class).to(RealBillingService.class); } } 3.2 @Inject 将注解@Inject放到service的构造方法上，Guice会去它的容器找到构造方法中的参数对应的bean，并设置给构造方法的参数。 public class RealBillingService implements BillingService { private final CreditCardProcessor processor; private final TransactionLog transactionLog; @Inject public RealBillingService(CreditCardProcessor processor, TransactionLog transactionLog) { this.processor = processor; this.transactionLog = transactionLog; } public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) { try { ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); } catch (UnreachableException e) { transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); } } } 3.3 createInjector 用该方法就可以初始化Guice里的容器： public static void main(String[] args) { Injector injector = Guice.createInjector(new BillingModule()); BillingService billingService = injector.getInstance(BillingService.class); ... } 并且使用injector可以从任意类获取到放进Guice中的bean。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-28 19:45:56 "},"chapter2/":{"url":"chapter2/","title":"Guice 快速上手","keywords":"","body":"Guice 快速上手 用一个简单的例子说明， 废话不多说，直接上最终的结果，通过注释轻松上手： import static java.lang.annotation.RetentionPolicy.RUNTIME; import com.google.inject.AbstractModule; import com.google.inject.Guice; import com.google.inject.Injector; import com.google.inject.Key; import com.google.inject.Provides; import java.lang.annotation.Retention; import javax.inject.Inject; import javax.inject.Qualifier; public class GuiceDemo { @Qualifier // javaEE提供的注解 @Retention(RUNTIME) @interface Message {} @Qualifier @Retention(RUNTIME) @interface Count {} /** * 用来绑定message和count的module，会被Greeter类依赖 * 除了下面的注解方法，还可以使用上一章中提到的bind方法进行绑定 */ static class DemoModule extends AbstractModule { @Provides // Guice提供的注解，表示会被放入Guice容器中 @Count // 用来帮助注入时别找错了bean static Integer provideCount() { return 3; } @Provides @Message static String provideMessage() { return \"hello world\"; } } static class Greeter { private final String message; private final int count; // Greeter类的构造方法表示它需要1个String类的参数和1个用来打印消息次数的int类参数 // 而@Inject表示这个构造方法可以被Guice使用 @Inject Greeter(@Message String message, @Count int count) { this.message = message; this.count = count; } void sayHello() { for (int i=0; i Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-29 16:39:19 "},"chapter3/":{"url":"chapter3/","title":"Guice 框架模型(mental modal)","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 Guice就是个map 1.1 Guice key 1.2 Guice Providers 2 使用 Guice 2.1 Configuration 2.2 Injection 3 依赖树状图 Guice 框架模型(mental modal) buzzword：梗 jargon：行话，术语 本章主要介绍Guice的实现模型，让我们更容易去思考这个框架的工作原理。 1 Guice就是个map 和spring中的ioc容器很像，Guice就是个map，其中的每一个entry包含2个部分： Guice key: map的key，存的是Guice定义的一个Key类 Provider: map的value，存的是Guice定义的一个Provider类，里面定义了如何返回我们想要的bean实例 1.1 Guice key 上一章快速上手中的Greeter类在构造方法中声明的2个依赖，在Guice map中的key是这样表示的： @Message String：map中为 Key @Count int：map中为 Key java中表示一个类型的key最简单的表达形式为： // 标识一个String类实例的依赖 Key databaseKey = Key.get(String.class); 但是程序总会有相同类型的依赖： final class MultilingualGreeter { private String englishGreeting; private String spanishGreeting; MultilingualGreeter(String englishGreeting, String spanishGreeting) { this.englishGreeting = englishGreeting; this.spanishGreeting = spanishGreeting; } } 因此Guice使用绑定注解(bind annotations)来区分相同类型的依赖，使之可以区分开是不同的依赖： @Inject MultilingualGreeter(@English String englishGreeting, @Spanish String spanishGreeting) { this.englishGreeting = englishGreeting; this.spanishGreeting = spanishGreeting; } 用了绑定注解后的key可以这样取： Key englishGreetingKey = Key.get(String.class, English.class); Key spanishGreetingKey = Key.get(String.class, Spanish.class); 最后，当程序调用Greeter的构造方法想获得两个参数的依赖时，实际上Guice内部帮我们做了这样的事： String english = injector.getInstance(Key.get(String.class, English.class)); String spanish = injector.getInstance(Key.get(String.class, Spanish.class)); MultilingualGreeter greeter = new MultilingualGreeter(english, spanish); 总结：Guice Key就是一个用来标明依赖，可以选择使用绑定注解搭配使用的一个类。 1.2 Guice Providers 这个value用来存bean的， Provider是个接口，声明了一个get方法: interface Provider { / 提供T类的实例 / T get(); } 每个实例了该接口的类都可以自定义你想要返回的类实例，可以使用： 直接new 用其它方法构造，比如反射 或者已经存进缓存中，直接反序列化等。 大多数程序不会选择直接实现该接口，而是去继承AbstractModule，通过configure来配置Guice的injector，injector内部会通过我们配置过的bean，自动去实现Provider。 比如上一章快速上手中， class DemoModule extends AbstractModule { @Provides @Count static Integer provideCount() { return 3; } @Provides @Message static String provideMessage() { return \"hello world\"; } } Provider：接口的get中调用provideMessage方法，返回\"hello world\" Provider：接口的get中调用provideCount方法，返回3 2 使用 Guice 要想使用Guice你得知道2个东西： Configuration：我们的程序需要往Guice map里塞东西 Injection：我们的程序叫Guice从它的map里创建和获取我们想要的bean实例 2.1 Configuration 怎么给Guice的配置塞东西，继而填充到Guice map里面？ 继承Guice的AbstractModule (或者Just-In-Time bindings)，通常有2种方式： 使用像@Provides这样的注解 全用Guice的Domain Specific Language (DSL) 概念上(Conceptually)，Guice的API提供了一些简单的方法来操作(manipulate)Guice map，并且直截了当，下面是java 8的语法写的一些例子，简单明了： Guice DSL syntax（我们程序中的写法） Mental model（Guice内部做的事） bind(key).toInstance(value) map.put(key, () -> value)(instance binding) bind(key).toProvider(provider) map.put(key, provider)(provider binding) bind(key).to(anotherKey) map.put(key, map.get(anotherKey))(linked binding) @Provides Foo provideFoo() {...} map.put(Key.get(Foo.class), module::provideFoo)(provider method binding) 2.2 Injection 依赖注入中最重要的事情就是，你只需要声明你需要这些依赖，自然会由容器返回给你想要的，而不是脱离容器的使用，自己从外面其它方式获得你想要的bean。 像下面这样： class Foo { private Database database; @Inject Foo(Database database) { // We need a database, from somewhere this.database = database; } } @Provides Database provideDatabase( // We need the @DatabasePath String before we can construct a Database @DatabasePath String databasePath) { return new Database(databasePath); } 3 依赖树状图 When injecting a thing that has dependencies of its own, Guice recursively injects the dependencies. 当注入A时，发现A还依赖B，然后去注入B，结果B又依赖C，接着就去注入C，这样dfs递归地向上遍历(up through)去注入会形成依赖的一条线的树状图。 为了使用Injector，Guice会去检查这个依赖树，如果出问题了会抛CreationException。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-29 22:19:35 "},"chapter4/":{"url":"chapter4/","title":"Guice bean的重用(scope)","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 内置的(built-in) scopes 1.1 单例(singleton) 1.2 RequestScoped 2 使用 scope 2.1 注解 2.2 bind 2.3 优先级 2.4 接口与实现类 3 饿汉 singleton 4 线程安全 5 测试 bean的重用(scope) 默认，Guice是返回的bean采用原型模式，但可以在以下不同级别的生命周期通过scope配置bean的reuse模式： application session request 1 内置的(built-in) scopes 1.1 单例(singleton) 可以使用内置的@Singleton注解让程序运行中，始终只能得到一个实例。 对于该注解，Guice支持2种包下的： java标准库：javax.inject.Singleton Guice提供的：com.google.inject.Singleton 不过使用java标准库的更好，因为该包下的注解同样被其它像Dagger一样的注入框架支持。 1.2 RequestScoped Guice提供的servlet扩展：servlet extension支持一些额外的有关web的注解，如@RequestScoped 2 使用 scope 2.1 注解 Guice使用注解来标明scope，只需要把有关scope的注解： 写到接口的实现类上 除功能性外(As well as being functional)，该注释还用作文档。例如，@singleton表示该类旨在为线程安全。 @Singleton public class InMemoryTransactionLog implements TransactionLog { /* everything here should be threadsafe! */ } 或者写在被@Provides注解过的方法上 @Provides @Singleton TransactionLog provideTransactionLog() { ... } 2.2 bind bind(TransactionLog.class).to(InMemoryTransactionLog.class).in(Singleton.class); bind()：指定Guice map中的Provider to()：指定bind()中引用的实现类 in()：(这句话建议读原文)接受either a scoping annotation like RequestScoped.class and also Scope instances like ServletScopes.REQUEST:in(RequestScoped.class); in(ServletScopes.REQUEST); 2.3 优先级 bind方法总是最优先的，如果使用注解写的scope不是想要的，可以直接使用bind方法绑定为Scopes.NO_SCOPE。 2.4 接口与实现类 如果1个类同时实现了2个接口，如下： public class Applebees implements Bar,Grill {} 然后在bind时写成如下代码： bind(Bar.class).to(Applebees.class).in(Singleton.class); bind(Grill.class).to(Applebees.class).in(Singleton.class); 这样写会生成两个单例的实例，一个Bar的，一个Grill的，但2个实例其实都是Applebees，因为Guice绑定的bean是源类，即bind()里面的参数，而不是to()里面的参数。 如果只想创建一个实例，把@Singleton写在实现类Applebees上，或者重新bind： bind(Applebees.class).in(Singleton.class); 这样上面的两个绑定的就没必要了，建议删掉。 3 饿汉 singleton 默认情况下，Guice使用懒汉加载单例，但也支持饿汉(Eager)单例： bind(TransactionLog.class).to(InMemoryTransactionLog.class).asEagerSingleton(); 使用枚举变量Stage来区分使用策略： 方法\\Stage PRODUCTION DEVELOPMENT .asEagerSingleton() eager eager .in(Singleton.class) eager lazy .in(Scopes.SINGLETON) eager lazy @Singleton eager* lazy 4 线程安全 被以下注解注解过的类必须是线程安全的： @Singleton @SessionScoped 而@RequestScoped注解过的类不必追求线程安全。 通常被@Singleton和@SessionScoped注解的类中如果依赖@RequestScoped注解过的类是错误的。 5 测试 如果想测试在使用了scope的Guice环境下的方法，却不关心具体的scope，可以使用Scopes.NO_SCOPE（没有scope就意味着使用默认的，即每次请求都是新的实例） import com.google.inject.Scopes; @RunWith(Junit4.class) final class FooTest { static class TestModule extends AbstractModule { @Override protected void configure() { bindScope(BatchScoped.class, Scopes.NO_SCOPE); } } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-29 21:41:49 "},"chapter5/":{"url":"chapter5/","title":"Guice 使用bindings(将bean放进容器中)","keywords":"","body":"Bindings overview 通过创建一个bind，可以往Guice map中插入一条新的记录entry。 有这么多种bind： Linked Bindings Binding Annotations Instance Bindings @Provides Methods Provider Bindings Untargeted Bindings Constructor Bindings Built-in Bindings Just-In-Time Bindings Multibindings Restricting the Binding Source 这句话不懂： The injector also includes bindings for the providers of its other bindings. Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-31 11:18:22 "},"chapter5/section1/":{"url":"chapter5/section1/","title":"1 Linked Bindings","keywords":"","body":"Linked Bindings 说白了就是将父类交给Guice管理，但是父类的引用指向真正的实现类。 官方说法：Linked bindings map a type to its implementation. 例如： public class BillingModule extends AbstractModule { @Provides TransactionLog provideTransactionLog(DatabaseTransactionLog impl) { return impl; } } 使用injector.getInstance(TransactionLog.class)时，当injector碰到有依赖该bean时，自动会将该bean的实现类赋给该bean，此例则会把DatabaseTransactionLog给TransactionLog。 当然，该方式存在传递性，例如： public class BillingModule extends AbstractModule { @Provides TransactionLog provideTransactionLog(DatabaseTransactionLog databaseTransactionLog) { return databaseTransactionLog; } @Provides DatabaseTransactionLog provideDatabaseTransactionLog(MySqlDatabaseTransactionLog impl) { return impl; } } 使用injector.getInstance(TransactionLog.class)时，会返回MySqlDatabaseTransactionLog。 一样的，除了使用注解方式外，还可以使用bind（在前面的章节中已经大量使用过）。 bind(DatabaseTransactionLog.class).to(MySqlDatabaseTransactionLog.class); Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-29 22:04:26 "},"chapter5/section2/":{"url":"chapter5/section2/","title":"2 Binding Annotations","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 含义 2 @Named Binding Annotations 1 含义 说人话就是，有时候可能想要给一个接口注入一个实现类，但是这个接口有两个实现类，但这两个实现类都被放进了容器里，此时就不知道该这个接口注入哪一个实现类了。 在Guice 框架模型(mental modal)中也提到过这个问题，只需要配合@Qualifer或者@BindingAnnotation(java元注解)使用即可，并且应该用在Guice map中的key为Key的对象里。 如下所示例子： package example.pizza; import static java.lang.annotation.ElementType.PARAMETER; import static java.lang.annotation.ElementType.FIELD; import static java.lang.annotation.ElementType.METHOD; import static java.lang.annotation.RetentionPolicy.RUNTIME; import java.lang.annotation.Target; import java.lang.annotation.Retention; import javax.inject.Qualifier; @Qualifier @Target({ FIELD, PARAMETER, METHOD }) @Retention(RUNTIME) public @interface PayPal {} // Older code may still use Guice `BindingAnnotation` in place of the standard // `@Qualifier` annotation. New code should use `@Qualifier` instead. @BindingAnnotation @Target({ FIELD, PARAMETER, METHOD }) @Retention(RUNTIME) public @interface GoogleCheckout {} 这些代码可以像Guice 快速上手写在单独一个java文件里，也可以直接写在使用这个注解的类里。 两种方式创建bindings，bind或@Provide： final class CreditCardProcessorModule extends AbstractModule { @Override protected void configure() { // This uses the optional `annotatedWith` clause in the `bind()` statement bind(CreditCardProcessor.class) .annotatedWith(PayPal.class) .to(PayPalCreditCardProcessor.class); } // This uses binding annotation with a @Provides method @Provides @GoogleCheckout CreditCardProcessor provideCheckoutProcessor( CheckoutCreditCardProcessor processor) { return processor; } } 然后像这样使用： @Inject public RealBillingService(@PayPal CreditCardProcessor processor,TransactionLog transactionLog) { ... } //或者 @Inject public RealBillingService(@GoogleCheckout CreditCardProcessor processor,TransactionLog transactionLog) { ... } 2 @Named 除了上面的方式，还可以使用@Named，它有一个String参数，通过指定具体的String，可以唯一标明一个实例： final class CreditCardProcessorModule extends AbstractModule { @Override protected void configure() { bind(CreditCardProcessor.class) .annotatedWith(Names.named(\"Checkout\")) //只要在依赖时，有注解@Named(\"Checkout\") .to(CheckoutCreditCardProcessor.class); //就给注入CheckoutCreditCardProcessor } } 依赖注入时： @Inject public RealBillingService(@Named(\"Checkout\") CreditCardProcessor processor, TransactionLog transactionLog) { ... } 但是不推荐这种@Named方式(sparingly保守使用)，因为编译器无法check string，最好还是像第1小节一样自定义自己的注解来实现唯一标识。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-29 22:34:58 "},"chapter5/section3/":{"url":"chapter5/section3/","title":"3 Instance Bindings","keywords":"","body":"Instance Bindings 通常，一个类没有其它依赖时，可以给它set一个它自己类型的实例对象。如： bind(String.class) .annotatedWith(Names.named(\"JDBC URL\")) .toInstance(\"jdbc:mysql://localhost/pizza\"); bind(Integer.class) .annotatedWith(Names.named(\"login timeout seconds\")) .toInstance(10); toInstance会降低程序启动速度，可以使用@Provides替代。 也可以使用bindConstant绑定常量： bindConstant() .annotatedWith(HttpPort.class) .to(8080); bindConstant是绑定基本数据类型(primitive)和其他常量类型(如String、enum和Class)的快捷方式。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-30 14:53:39 "},"chapter5/section4/":{"url":"chapter5/section4/","title":"4 @Provides Methods","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 配合Binding Annotation使用 2 异常 @Provides Methods 被@Provides注解的方法（静态方法或实例方法）必须写在继承了AbstractModule的类里面，而且这个方法的返回值就是将被放进Guice map里的Provider中被绑定的bean(bind())，至于具体的实现类是啥(to())，就看方法里是怎么写的了。 public class BillingModule extends AbstractModule { @Override protected void configure() { ... } @Provides static TransactionLog provideTransactionLog() { DatabaseTransactionLog transactionLog = new DatabaseTransactionLog(); transactionLog.setJdbcUrl(\"jdbc:mysql://localhost/pizza\"); transactionLog.setThreadPoolSize(30); return transactionLog; } } 1 配合Binding Annotation使用 如果@ providers注解的方法有@PayPal或@Named(“Checkout”)这样的绑定注释，Guice就会绑定带注释的类型。依赖项可以作为参数传递给方法。在调用方法之前，注入器会对每一个变量执行绑定。 @Provides @PayPal CreditCardProcessor providePayPalCreditCardProcessor(@Named(\"PayPal API key\") String apiKey) { PayPalCreditCardProcessor processor = new PayPalCreditCardProcessor(); processor.setApiKey(apiKey); return processor; } 2 异常 Guice不允许从Providers中抛异常，被@Provides注解的方法抛出的异常会被包含进ProvisionException，如果你真的想抛自定义的异常，去看一下ThrowingProviders extension中的@CheckedProvides Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-30 15:20:59 "},"chapter5/section5/":{"url":"chapter5/section5/","title":"5 Provider Bindings","keywords":"","body":"Provider Bindings 当@Provides注解过的方法可以称之为Provider，因为它们其实在内部是实现了一个叫Provider的接口： public interface Provider { T get(); } 每一个方法在Guice内部都是Provider的一个实现类，因此我们也可以去实现Provider来实现binding： public class DatabaseTransactionLogProvider implements Provider { private final Connection connection; @Inject public DatabaseTransactionLogProvider(Connection connection) { this.connection = connection; } public TransactionLog get() { DatabaseTransactionLog transactionLog = new DatabaseTransactionLog(); transactionLog.setConnection(connection); return transactionLog; } } 最后我们需要使用.toProvider来将binding放进Guice map： public class BillingModule extends AbstractModule { @Override protected void configure() { bind(TransactionLog.class) .toProvider(DatabaseTransactionLogProvider.class); } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-30 15:31:27 "},"chapter5/section6/":{"url":"chapter5/section6/","title":"6 Untargeted Bindings","keywords":"","body":"Untargeted Bindings 绑定没有实现类的bean，即有bind()没有to()的bean。 This is most useful for concrete classes and types annotated by either @ImplementedBy or @ProvidedBy. An untargetted binding informs the injector about a type, so it may prepare dependencies eagerly. Untargetted bindings have no to clause, like so: 因为没有具体的实现类，所以injector会采用饿汉模式，去找到容器中对应的父类bean或子类bean，赶紧set给这个binding，这对容器中被@ImplementedBy或@ProvidedBy注解过的父类并且还有具体的实现类的情况很有用： bind(MyConcreteClass.class); bind(AnotherConcreteClass.class).in(Singleton.class); Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-30 15:41:15 "},"chapter5/section7/":{"url":"chapter5/section7/","title":"7 Constructor Bindings","keywords":"","body":"Constructor Bindings 有时候会碰到一种情况，就是你想绑定给某个类一个具体的实现类，但你无法做到，因为你无法将@Inject写到实现类的构造方法上，比如你想将第三方jar包中的类，或者一个类有多个构造方法都被@Inject注解，然后导入Guice map管理，@Provides Methods可以解决这个问题， 但是存在一个问题，即通过Provider的方法去new一个第三方的类，这样不能被切面AOP注入。 Guice有一个toConstructor()，其中可以通过反射来找到实现类的构造方法，如果找不到则处理一个异常即可： public class BillingModule extends AbstractModule { @Override protected void configure() { try { bind(TransactionLog.class).toConstructor( DatabaseTransactionLog.class.getConstructor(DatabaseConnection.class)); } catch (NoSuchMethodException e) { addError(e); } } } 在此示例中，DataBaseTransactionLog必须具有一个构造函数，该构造函数采用单个databaseconnection参数。该构造函数不需要@Inject注释。Guice将调用该构造函数以满足绑定。 每个ToConstructor()绑定都是独立范围范围的。如果创建针对同一构造函数的多个单例绑定，则每个绑定都会产生其自己的实例。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-30 17:05:30 "},"chapter5/section8/":{"url":"chapter5/section8/","title":"8 Built-in Bindings","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 Loggers 2 The Injector 3 Providers 4 TypeLiterals 5 The Stage 6 MembersInjectors Built-in Bindings 本节介绍内置building。 但除了Provider这种内置building之外，其它的内置building应该避免使用。 除了显式绑定和即时绑定外(Alongside explicit and just-in-time bindings)，注入器还会自动包含其他绑定。 只有Injector才能创建这些绑定，如果自己尝试绑定它们将会出错。 1 Loggers Guice自带了一个java.util.logging.Logger的内置绑定，目的是保存一些样板文件，用户可以直接使用。绑定会自动将logger的名称设置为要注入logger的类的名称。 @Singleton public class ConsoleTransactionLog implements TransactionLog { private final Logger logger; @Inject public ConsoleTransactionLog(Logger logger) { this.logger = logger; } public void logConnectException(UnreachableException e) { /* the message is logged to the \"ConsoleTransacitonLog\" logger */ logger.warning(\"Connect exception failed, \" + e.getMessage()); } 2 The Injector 在框架代码中，有时直到运行时你才知道你需要的类型。在这种罕见的情况下，您应该注入注入器。注入注入器的代码不会对其依赖项进行自我文档化(self-document)，因此应该少用这种方法。 3 Providers For every type Guice knows about, it can also inject a Provider of that type. Injecting Providers describes this in detail. 4 TypeLiterals If you're injecting parameterized types, you can inject a TypeLiteral to reflectively tell you the element type. 5 The Stage Guice supports a stage enum to differentiate between development and production runs. 6 MembersInjectors 在绑定到提供程序或编写扩展时，您可能希望Guice将依赖项注入到您自己构造的对象中。为此，添加一个MembersInjector的依赖(其中T是你的对象的类型)，然后调用MembersInjector.injectmembers(myNewObject)。当调用injectMembers时，Guice将对myNewObject执行字段和方法注入(field and method injection)。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-31 09:59:54 "},"chapter5/section9/":{"url":"chapter5/section9/","title":"9 Just-in-time Bindings","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 @Inject Constructors 2 @ImplementedBy 3 @ProvidedBy 4 Enforce Explicit Bindings Just-in-time Bindings 这个是被Guice自动进行绑定的一个操作。 显式绑定：声明在Module的binding 隐式绑定：或称为Just-in-time(JIT) Bindings，即没有声明在Module中的binding，当用到时，Guice将尝试创建需要用到的binding 1 @Inject Constructors 可注入的构造方法有如下两类： 被@Inject显式注解过的构造方法 或者虽然没有被@Inject显式注解过，但是无参构造方法，且类和构造方法必须都是public的，因为反射是有成本的。 如： public final class Foo { // An @Inject annotated constructor. @Inject Foo(Bar bar) { ... } } public final class Bar { // A no-arg non private constructor. Bar() {} private static class Baz { // A private constructor to a private class is also usable by Guice, but // this is not recommended since it can be slow. private Baz() {} } } 不能被注入的构造方法： 被有被@Inject显示注解的构造方法中还有参数 一个类中有多个构造方法被@Inject注解 构造方法被定义在普通内部类里：内部类对其外围类有一个隐式引用，不能注入。 如： public final class Foo { // Not injectable because the construct takes an argument and there is no // @Inject annotation. Foo(Bar bar) { ... } } public final class Bar { // Not injectable because the constructor is private private Bar() {} class Baz { // Not injectable because Baz is not a static inner class Baz() {} } } 应用程序可以通过在Module中调用binder().requireAtInjectRequired()来强制Guice只使用@Inject注解的构造函数。当选择注入时，Guice将只考虑@Inject注解的构造函数，如果没有，则报告MISSING_CONSTRUCTOR。 tip: 使用Modules.requireAtInjectOnConstructorsModule()来在构造函数需求中为@Inject选择。 2 @ImplementedBy 该注解是告诉一个类的默认实现类是啥，和Linked Bindings差不多。 @ImplementedBy(PayPalCreditCardProcessor.class) public interface CreditCardProcessor { ChargeResult charge(String amount, CreditCard creditCard) throws UnreachableException; } 和下面这个一样： bind(CreditCardProcessor.class).to(PayPalCreditCardProcessor.class); 但绑定的type如果两种方法都用了，以bind()优先。 由于@ImplementedBy是编译时的依赖，因此会被运行时的bind()给覆盖。 3 @ProvidedBy @ProvidedBy告诉Injector可以创建实例的Provider。 @ProvidedBy(DatabaseTransactionLogProvider.class) public interface TransactionLog { void logConnectException(UnreachableException e); void logChargeResult(ChargeResult result); } 等价于： bind(TransactionLog.class).toProvider(DatabaseTransactionLogProvider.class); 和@ImplementedBy一样，上面两种情况如果都用了，以bind()为准。 4 Enforce Explicit Bindings 为了禁止隐式绑定，可以使用requireExplicitBindings： final class ExplicitBindingModule extends AbstractModule { @Override protected void configure() { binder().requireExplicitBindings(); } } 使用了之后，就必须得将所有需要注入的binding写在Module里。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-31 10:42:31 "},"chapter5/section10/":{"url":"chapter5/section10/","title":"10 Multibindings","keywords":"","body":"Multibindings Multibindings Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-31 10:44:22 "},"chapter5/section11/":{"url":"chapter5/section11/","title":"11 Restricting the Binding Source","keywords":"","body":"Restricting the Binding Source Restricting the Binding Source Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-31 10:45:47 "},"chapter6/":{"url":"chapter6/","title":"Guice 注入总结(从容器中将bean拿出来)","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 Constructor Injection 2 Method Injection 3 Field Injection 4 Optional Injections 5 On-demand Injection 6 Static Injections 7 Automatic Injection 8 Injection Points Guice 注入原理 依赖注入模式将行为与依赖解析分离开来。该模式建议传入依赖关系，而不是直接查找依赖关系或从工厂查找依赖关系。将依赖项设置到对象中的过程称为注入。 1 Constructor Injection 构造仪注入将实例化与注入相结合。要使用它，请用@Inject注释注释构造函数。该构造函数应接受类依赖性作为参数。然后，大多数构造函数将把参数分配给最终字段。 public class RealBillingService implements BillingService { private final CreditCardProcessor processorProvider; private final TransactionLog transactionLogProvider; @Inject RealBillingService(CreditCardProcessor processorProvider, TransactionLog transactionLogProvider) { this.processorProvider = processorProvider; this.transactionLogProvider = transactionLogProvider; } 如果类没有带@inject注解的构造函数，Guice将使用一个公共的无参数构造函数(如果它存在的话)。 最好使用注解，它记录了该类型参与了依赖注入。 构造函数注入与单元测试配合得很好。如果您的类在一个构造函数中接受它的所有依赖项，您就不会意外地忘记设置依赖项。当引入一个新的依赖项时，所有的调用代码都会很方便地中断!修复编译错误，您就可以确信一切都已正确连接。 2 Method Injection 方法注入意味着被注入的类是可变的(mutable)，这通常应该避免。所以最好选择构造函数注入而不是方法注入。 Guice可以注入具有@Inject注释的方法。依赖采用参数的形式，注入器在调用方法之前解析这些参数。注入的方法可以有任意数量的参数，方法名不会影响注入。 public class PayPalCreditCardProcessor implements CreditCardProcessor { private static final String DEFAULT_API_KEY = \"development-use-only\"; private String apiKey = DEFAULT_API_KEY; @Inject public void setApiKey(@Named(\"PayPal API key\") String apiKey) { this.apiKey = apiKey; } 3 Field Injection 与方法注入相同，字段注入意味着被注入的类是可变的，这通常应该避免。所以最好选择构造函数注入，而不是字段注入。 Guice用@Inject注释注入字段。这是最简洁的注入，但最不可测试。 public class DatabaseTransactionLogProvider implements Provider { @Inject Connection connection; public TransactionLog get() { return new DatabaseTransactionLog(connection); } } Avoid using field injection with final fields, which has weak semantics). 4 Optional Injections tip: 首选OptionalBinder而不是@Inject(optional = true)。 有时，在存在依赖项时使用依赖项，在不存在依赖项时回退到默认依赖项会很方便。 方法和字段注入可能是可选的，这将导致Guice在依赖项不可用时静默地忽略它们。要使用可选注入，请应用@Inject(optional=true)注解 public class PayPalCreditCardProcessor implements CreditCardProcessor { private static final String SANDBOX_API_KEY = \"development-use-only\"; private String apiKey = SANDBOX_API_KEY; @Inject(optional=true) public void setApiKey(@Named(\"PayPal API key\") String apiKey) { this.apiKey = apiKey; } 混合可选的注入和即时绑定可能会产生令人惊讶的结果。例如，即使没有显式绑定Date，也始终会注入以下字段。这是因为Date有一个公共的无参数构造函数，适合即时绑定。 @Inject(optional=true) Date launchDate; 5 On-demand Injection 方法和字段注入可用于初始化现有实例。你可以使用Injector.injectMembersAPI public static void main(String[] args) { Injector injector = Guice.createInjector(...); CreditCardProcessor creditCardProcessor = new PayPalCreditCardProcessor(); injector.injectMembers(creditCardProcessor); 6 Static Injections 在将应用程序从静态工厂迁移到Guice时，可以进行增量更改。 静态注入在这里是一个很有用的工具。通过获得对注入类型的访问，而无需自身被注入，对象可以部分参与依赖项注入。在模块中使用requestStaticInjection()来指定在创建注入器时要注入的类 @Override public void configure() { requestStaticInjection(ProcessorFactory.class); ... } Guice将注入具有@Inject注释的类的静态成员 class ProcessorFactory { @Inject static Provider processorProvider; /** * @deprecated prefer to inject your processor instead. */ @Deprecated public static Processor getInstance() { return processorProvider.get(); } } 静态成员不会在实例注入时注入。 不建议将此API用于一般用途，因为它存在许多与静态工厂相同的问题:测试起来很笨拙，使依赖关系不透明，并且依赖全局状态。 7 Automatic Injection Guice会自动对以下类型的对象执行字段和方法注入: 在绑定语句中传递给toInstance()的实例 在绑定语句中传递给toProvider()的实例。 这些注入会作为创建注入器的一部分执行。 8 Injection Points An injection point is a place in the code where Guice has been asked to inject a dependency. Example injection points: parameters of an injectable constructor parameters of a @Provides method parameters of an @Inject annotated method fields annotated with @Inject Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-31 11:21:55 "},"chapter6/section1/":{"url":"chapter6/section1/","title":"1 Injecting Providers","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 Providers for multiple instances 2 Providers for lazy loading 3 Providers for Mixing Scopes Injecting Providers 对于普通的依赖项注入，每个类型都得到它的每个依赖类型的一个实例。 RealBillingService获得一个CreditCardProcessor和一个TransactionLog。 有时需要依赖类型的多个实例。当需要这种灵活性时，Guice会绑定提供者。当调用get()方法时，提供程序生成一个值: public interface Provider { T get(); } 将provider的type参数化，以区分Provider和Provider。无论在何处注入值，都可以为该值注入provider。 public class RealBillingService implements BillingService { private final Provider processorProvider; private final Provider transactionLogProvider; @Inject public RealBillingService(Provider processorProvider, Provider transactionLogProvider) { this.processorProvider = processorProvider; this.transactionLogProvider = transactionLogProvider; } public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) { CreditCardProcessor processor = processorProvider.get(); TransactionLog transactionLog = transactionLogProvider.get(); /* use the processor and transaction log here */ } } 对于每一个绑定，不管有没有注解，注入器都为它的Provider提供了一个内置绑定。 1 Providers for multiple instances 当需要同一类型的多个实例时，请使用Provider。假设您的应用程序在比萨饼收费失败时保存了一个摘要条目和详细信息。通过Provider，您可以在需要的时候获得一个新条目： public class LogFileTransactionLog implements TransactionLog { private final Provider logFileProvider; @Inject public LogFileTransactionLog(Provider logFileProvider) { this.logFileProvider = logFileProvider; } public void logChargeResult(ChargeResult result) { LogFileEntry summaryEntry = logFileProvider.get(); summaryEntry.setText(\"Charge \" + (result.wasSuccessful() ? \"success\" : \"failure\")); summaryEntry.save(); if (!result.wasSuccessful()) { LogFileEntry detailEntry = logFileProvider.get(); detailEntry.setText(\"Failure result: \" + result); detailEntry.save(); } } 2 Providers for lazy loading 如果您对某个类型有依赖，而该类型的生成成本特别高，那么您可以使用Provider来延迟该工作。当您不总是需要依赖项时，这尤其有用： public class DatabaseTransactionLog implements TransactionLog { private final Provider connectionProvider; @Inject public DatabaseTransactionLog(Provider connectionProvider) { this.connectionProvider = connectionProvider; } public void logChargeResult(ChargeResult result) { /* only write failed charges to the database */ if (!result.wasSuccessful()) { Connection connection = connectionProvider.get(); } } 3 Providers for Mixing Scopes 直接注入范围较窄的对象通常会导致应用程序中出现意外行为。 在下面的示例中，假设您有一个独立的ConsoleTransactionLog，它依赖于请求作用域的当前用户。 如果将用户直接注入到ConsoleTransactionLog构造函数中，那么在应用程序的整个生命周期中，用户只会被评估一次。这种行为是不正确的， 因为每一个请求的用户都不一样。因此应该使用Provider。 由于提供程序按需生成值，因此它们使您能够安全地混合作用域： @Singleton public class ConsoleTransactionLog implements TransactionLog { private final AtomicInteger failureCount = new AtomicInteger(); private final Provider userProvider; @Inject public ConsoleTransactionLog(Provider userProvider) { this.userProvider = userProvider; } public void logConnectException(UnreachableException e) { failureCount.incrementAndGet(); User user = userProvider.get(); System.out.println(\"Connection failed for \" + user + \": \" + e.getMessage()); System.out.println(\"Failure count: \" + failureCount.incrementAndGet()); } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-31 11:32:06 "},"chapter7/":{"url":"chapter7/","title":"Guice AOP","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 Example: Forbidding method calls on weekends 2 Limitations 3 Injecting Interceptors Guice AOP Aspect Oriented Programming 使用Guice拦截方法。 为了补充依赖注入，Guice支持方法拦截。此特性使您能够编写每次调用匹配方法时执行的代码。 它适用于横切关注点(“方面”)，例如事务、安全性和日志。因为拦截器将问题划分为方面而不是对象，所以它们的使用被称为面向切面编程(AOP)。 大多数开发人员不会直接编写方法拦截器；但是他们可能会看到在像 Warp Persist这样的集成库中的使用时，确实需要选择匹配方法，创建拦截器并将其全部配置在Module中。 Matcher是一个简单的接口，它可以接受或拒绝一个值。对于Guice AOP，需要两个匹配器: 一个定义参与的类， 另一个定义这些类的方法。 为了简单起见，有一个工厂类来满足常见的场景。 每当调用匹配的方法时，都会执行MethodInterceptors。 他们有机会检查调用:方法、参数和接收实例。 它们可以执行横切逻辑，然后委托给底层方法。 它们可以检查返回值或异常并返回。 由于拦截器可以应用于许多方法，并将接收许多调用，它们的实现应该是有效的和不受干扰的。 1 Example: Forbidding method calls on weekends 为了说明方法拦截器如何使用Guice，我们将禁止在周末调用披萨账单系统。送餐员只在周一到周五工作，所以我们会防止在送不出去的时候有人点披萨!这个示例在结构上类似于使用AOP进行授权。 为了将选择方法标记为仅限工作日，我们定义了一个注解： @Retention(RetentionPolicy.RUNTIME) @Target(ElementType.METHOD) @interface NotOnWeekends {} 把它应用到需要被拦截的方法上： public class RealBillingService implements BillingService { @NotOnWeekends public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) { ... } } 接下来，我们通过实现org.aopalliance.intercept.MethodInterceptor接口来定义拦截器。当需要通过底层方法进行调用时，可以调用invoke.proceed() public class WeekendBlocker implements MethodInterceptor { public Object invoke(MethodInvocation invocation) throws Throwable { Calendar today = new GregorianCalendar(); if (today.getDisplayName(DAY_OF_WEEK, LONG, ENGLISH).startsWith(\"S\")) { throw new IllegalStateException( invocation.getMethod().getName() + \" not allowed on weekends!\"); } return invocation.proceed(); } } 最后，我们配置一切。那就是我们为要拦截的类和方法创建匹配器的地方。 在本例中，我们匹配任何类，但只匹配带有@NotOnWeekends注释的方法： public class NotOnWeekendsModule extends AbstractModule { protected void configure() { bindInterceptor(Matchers.any(), Matchers.annotatedWith(NotOnWeekends.class), new WeekendBlocker()); } } 把这些配置好后，然后等到周六时，如果有人下单，可以看到该方法被拦截，订单被拒绝： Exception in thread \"main\" java.lang.IllegalStateException: chargeOrder not allowed on weekends! at com.publicobject.pizza.WeekendBlocker.invoke(WeekendBlocker.java:65) at com.google.inject.internal.InterceptorStackCallback.intercept(...) at com.publicobject.pizza.RealBillingService$$EnhancerByGuice$$49ed77ce.chargeOrder() at com.publicobject.pizza.WeekendExample.main(WeekendExample.java:47) 2 Limitations 在底层，方法拦截是通过在运行时生成字节码来实现的。 Guice通过重写方法动态创建一个子类，该子类应用拦截器。如果您所处的平台不支持字节码生成(比如Android)，那么应该使用不支持AOP的Guice。 这种方法对可以拦截的类和方法施加了限制： 类必须是public或package-private。 类必须是非final的方法必须是public， package-private或protected方法必须是非final的。 实例必须由Guice通过带有@inject注解的或无参数的构造函数创建。 不可能对不是由Guice构造的实例使用方法拦截。 3 Injecting Interceptors 如果你需要将依赖项注入拦截器，可以使用requestInjection API。 public class NotOnWeekendsModule extends AbstractModule { protected void configure() { WeekendBlocker weekendBlocker = new WeekendBlocker(); requestInjection(weekendBlocker); bindInterceptor(Matchers.any(), Matchers.annotatedWith(NotOnWeekends.class), weekendBlocker); } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-31 11:49:20 "}}