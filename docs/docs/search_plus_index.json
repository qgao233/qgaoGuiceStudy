{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction guice home Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-25 19:00:00 "},"chapter1/":{"url":"chapter1/","title":"Guice 起因(发音juice)","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 传统的写法 1.1 BillingService 1.2 Factories 1.3 unit test 2 依赖注入 3 Guice里的依赖注入 3.1 AbstractModule 3.2 @Inject 3.3 createInjector Guice 起因 将各个模块连接起来是比较枯燥(tedious)的，用一个使用信用卡支付账单的例子来讲解为何开发Guice框架。 1 传统的写法 1.1 BillingService 在支付账单的service里，直接使用new的方式去获取两个工具类来达到真正地支付的操作： PaypalCreditCardProcessor DatabaseTransactionLog public class RealBillingService implements BillingService { public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) { CreditCardProcessor processor = new PaypalCreditCardProcessor(); TransactionLog transactionLog = new DatabaseTransactionLog(); try { ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); } catch (UnreachableException e) { transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); } } } 1.2 Factories 感觉直接new两个工具类不太好，于是决定用工厂模式替代直接new的方式，并达到解耦(decouple)service和工具类的工作。 下面是根据工厂模式的模板(boilerplate)代码写的： public class CreditCardProcessorFactory { private static CreditCardProcessor instance; public static void setInstance(CreditCardProcessor processor) { instance = processor; } public static CreditCardProcessor getInstance() { if (instance == null) { return new SquareCreditCardProcessor(); } return instance; } } 更新后的service： CreditCardProcessor processor = CreditCardProcessorFactory.getInstance(); TransactionLog transactionLog = TransactionLogFactory.getInstance(); 1.3 unit test 在测试启动关闭时将两个工具类设值或Null，但是这个代码很蠢，因为一个真正的业务factory居然保存了两个用来测试的工具类。 所以我们需要很谨慎地来设置factory里的值，一旦在测试时teardown方法执行失败，那么factory里的两个工具类就会影响到其它依赖该factory的程序。 而且最大的问题是service通过factory依赖的两个工具类是隐藏在代码里面的，对client是完全透明的，一旦我们忘记service里需要依赖这两个工具类，从而不在client里给factory设值，程序就运行崩溃了(attempted)。 public class RealBillingServiceTest extends TestCase { private final PizzaOrder order = new PizzaOrder(100); private final CreditCard creditCard = new CreditCard(\"1234\", 11, 2010); private final InMemoryTransactionLog transactionLog = new InMemoryTransactionLog(); private final FakeCreditCardProcessor processor = new FakeCreditCardProcessor(); @Override public void setUp() { TransactionLogFactory.setInstance(transactionLog); CreditCardProcessorFactory.setInstance(processor); } @Override public void tearDown() { TransactionLogFactory.setInstance(null); CreditCardProcessorFactory.setInstance(null); } public void testSuccessfulCharge() { RealBillingService billingService = new RealBillingService(); Receipt receipt = billingService.chargeOrder(order, creditCard); assertTrue(receipt.hasSuccessfulCharge()); assertEquals(100, receipt.getAmountOfCharge()); assertEquals(creditCard, processor.getCardOfOnlyCharge()); assertEquals(100, processor.getAmountOfOnlyCharge()); assertTrue(transactionLog.wasSuccessLogged()); } } 2 依赖注入 这个设计模式的核心是依赖倒转原则(separate behaviour from dependency resolution)。 依赖倒转原则认为，service不应该负责去寻找到两个具体的工具类，而应该是外部找到注入给service的。 并且注入的方式应该是通过构造方法的方式注入，这样该类需要什么参数，一目了然。 The dependency is exposed in the API signature. 更改service后的代码： public class RealBillingService implements BillingService { private final CreditCardProcessor processor; private final TransactionLog transactionLog; public RealBillingService(CreditCardProcessor processor,TransactionLog transactionLog) { this.processor = processor; this.transactionLog = transactionLog; } public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) { try { ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); } catch (UnreachableException e) { transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); } } } 3 Guice里的依赖注入 Guice框架底层已经把实现搞定，我们需要做的事就是将我们的接口对应到它们的实现。 3.1 AbstractModule 用上面的例子举例，首先得自定义一个Module类去继承Guice提供的AbstractModule。 public class BillingModule extends AbstractModule { @Override protected void configure() { bind(TransactionLog.class).to(DatabaseTransactionLog.class); bind(CreditCardProcessor.class).to(PaypalCreditCardProcessor.class); bind(BillingService.class).to(RealBillingService.class); } } 3.2 @Inject 将注解@Inject放到service的构造方法上，Guice会去它的容器找到构造方法中的参数对应的bean，并设置给构造方法的参数。 public class RealBillingService implements BillingService { private final CreditCardProcessor processor; private final TransactionLog transactionLog; @Inject public RealBillingService(CreditCardProcessor processor, TransactionLog transactionLog) { this.processor = processor; this.transactionLog = transactionLog; } public Receipt chargeOrder(PizzaOrder order, CreditCard creditCard) { try { ChargeResult result = processor.charge(creditCard, order.getAmount()); transactionLog.logChargeResult(result); return result.wasSuccessful() ? Receipt.forSuccessfulCharge(order.getAmount()) : Receipt.forDeclinedCharge(result.getDeclineMessage()); } catch (UnreachableException e) { transactionLog.logConnectException(e); return Receipt.forSystemFailure(e.getMessage()); } } } 3.3 createInjector 用该方法就可以初始化Guice里的容器： public static void main(String[] args) { Injector injector = Guice.createInjector(new BillingModule()); BillingService billingService = injector.getInstance(BillingService.class); ... } 并且使用injector可以从任意类获取到放进Guice中的bean。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-28 19:45:56 "},"chapter2/":{"url":"chapter2/","title":"Guice 快速上手","keywords":"","body":"Guice 快速上手 用一个简单的例子说明， 废话不多说，直接上最终的结果，通过注释轻松上手： import static java.lang.annotation.RetentionPolicy.RUNTIME; import com.google.inject.AbstractModule; import com.google.inject.Guice; import com.google.inject.Injector; import com.google.inject.Key; import com.google.inject.Provides; import java.lang.annotation.Retention; import javax.inject.Inject; import javax.inject.Qualifier; public class GuiceDemo { @Qualifier // javaEE提供的注解 @Retention(RUNTIME) @interface Message {} @Qualifier @Retention(RUNTIME) @interface Count {} /** * 用来绑定message和count的module，会被Greeter类依赖 * 除了下面的注解方法，还可以使用上一章中提到的bind方法进行绑定 */ static class DemoModule extends AbstractModule { @Provides // Guice提供的注解，表示会被放入Guice容器中 @Count // 用来帮助注入时别找错了bean static Integer provideCount() { return 3; } @Provides @Message static String provideMessage() { return \"hello world\"; } } static class Greeter { private final String message; private final int count; // Greeter类的构造方法表示它需要1个String类的参数和1个用来打印消息次数的int类参数 // 而@Inject表示这个构造方法可以被Guice使用 @Inject Greeter(@Message String message, @Count int count) { this.message = message; this.count = count; } void sayHello() { for (int i=0; i Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-29 16:39:19 "},"chapter3/":{"url":"chapter3/","title":"Guice 框架模型(mental modal)","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 Guice就是个map 1.1 Guice key 1.2 Guice Providers 2 使用 Guice 2.1 Configuration 2.2 Injection 3 依赖树状图 Guice 框架模型(mental modal) buzzword：梗 jargon：行话，术语 本章主要介绍Guice的实现模型，让我们更容易去思考这个框架的工作原理。 1 Guice就是个map 和spring中的ioc容器很像，Guice就是个map，其中的每一个entry包含2个部分： Guice key: map的key，存的是Guice定义的一个Key类 Provider: map的value，存的是Guice定义的一个Provider类，里面定义了如何返回我们想要的bean实例 1.1 Guice key 上一章快速上手中的Greeter类在构造方法中声明的2个依赖，在Guice map中的key是这样表示的： @Message String：map中为 Key @Count int：map中为 Key java中表示一个类型的key最简单的表达形式为： // 标识一个String类实例的依赖 Key databaseKey = Key.get(String.class); 但是程序总会有相同类型的依赖： final class MultilingualGreeter { private String englishGreeting; private String spanishGreeting; MultilingualGreeter(String englishGreeting, String spanishGreeting) { this.englishGreeting = englishGreeting; this.spanishGreeting = spanishGreeting; } } 因此Guice使用绑定注解(bind annotations)来区分相同类型的依赖，使之可以区分开是不同的依赖： @Inject MultilingualGreeter(@English String englishGreeting, @Spanish String spanishGreeting) { this.englishGreeting = englishGreeting; this.spanishGreeting = spanishGreeting; } 用了绑定注解后的key可以这样取： Key englishGreetingKey = Key.get(String.class, English.class); Key spanishGreetingKey = Key.get(String.class, Spanish.class); 最后，当程序调用Greeter的构造方法想获得两个参数的依赖时，实际上Guice内部帮我们做了这样的事： String english = injector.getInstance(Key.get(String.class, English.class)); String spanish = injector.getInstance(Key.get(String.class, Spanish.class)); MultilingualGreeter greeter = new MultilingualGreeter(english, spanish); 总结：Guice Key就是一个用来标明依赖，可以选择使用绑定注解搭配使用的一个类。 1.2 Guice Providers 这个value用来存bean的， Provider是个接口，声明了一个get方法: interface Provider { / 提供T类的实例 / T get(); } 每个实例了该接口的类都可以自定义你想要返回的类实例，可以使用： 直接new 用其它方法构造，比如反射 或者已经存进缓存中，直接反序列化等。 大多数程序不会选择直接实现该接口，而是去继承AbstractModule，通过configure来配置Guice的injector，injector内部会通过我们配置过的bean，自动去实现Provider。 比如上一章快速上手中， class DemoModule extends AbstractModule { @Provides @Count static Integer provideCount() { return 3; } @Provides @Message static String provideMessage() { return \"hello world\"; } } Provider：接口的get中调用provideMessage方法，返回\"hello world\" Provider：接口的get中调用provideCount方法，返回3 2 使用 Guice 要想使用Guice你得知道2个东西： Configuration：我们的程序需要往Guice map里塞东西 Injection：我们的程序叫Guice从它的map里创建和获取我们想要的bean实例 2.1 Configuration 怎么给Guice的配置塞东西，继而填充到Guice map里面？ 继承Guice的AbstractModule (或者Just-In-Time bindings)，通常有2种方式： 使用像@Provides这样的注解 全用Guice的Domain Specific Language (DSL) 概念上(Conceptually)，Guice的API提供了一些简单的方法来操作(manipulate)Guice map，并且直截了当，下面是java 8的语法写的一些例子，简单明了： Guice DSL syntax（我们程序中的写法） Mental model（Guice内部做的事） bind(key).toInstance(value) map.put(key, () -> value)(instance binding) bind(key).toProvider(provider) map.put(key, provider)(provider binding) bind(key).to(anotherKey) map.put(key, map.get(anotherKey))(linked binding) @Provides Foo provideFoo() {...} map.put(Key.get(Foo.class), module::provideFoo)(provider method binding) 2.2 Injection 依赖注入中最重要的事情就是，你只需要声明你需要这些依赖，自然会由容器返回给你想要的，而不是脱离容器的使用，自己从外面其它方式获得你想要的bean。 像下面这样： class Foo { private Database database; @Inject Foo(Database database) { // We need a database, from somewhere this.database = database; } } @Provides Database provideDatabase( // We need the @DatabasePath String before we can construct a Database @DatabasePath String databasePath) { return new Database(databasePath); } 3 依赖树状图 When injecting a thing that has dependencies of its own, Guice recursively injects the dependencies. 当注入A时，发现A还依赖B，然后去注入B，结果B又依赖C，接着就去注入C，这样dfs递归地向上遍历(up through)去注入会形成依赖的一条线的树状图。 为了使用Injector，Guice会去检查这个依赖树，如果出问题了会抛CreationException。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-29 22:19:35 "},"chapter4/":{"url":"chapter4/","title":"Guice bean的重用(scope)","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 内置的(built-in) scopes 1.1 单例(singleton) 1.2 RequestScoped 2 使用 scope 2.1 注解 2.2 bind 2.3 优先级 2.4 接口与实现类 3 饿汉 singleton 4 线程安全 5 测试 bean的重用(scope) 默认，Guice是返回的bean采用原型模式，但可以在以下不同级别的生命周期通过scope配置bean的reuse模式： application session request 1 内置的(built-in) scopes 1.1 单例(singleton) 可以使用内置的@Singleton注解让程序运行中，始终只能得到一个实例。 对于该注解，Guice支持2种包下的： java标准库：javax.inject.Singleton Guice提供的：com.google.inject.Singleton 不过使用java标准库的更好，因为该包下的注解同样被其它像Dagger一样的注入框架支持。 1.2 RequestScoped Guice提供的servlet扩展：servlet extension支持一些额外的有关web的注解，如@RequestScoped 2 使用 scope 2.1 注解 Guice使用注解来标明scope，只需要把有关scope的注解： 写到接口的实现类上 除功能性外(As well as being functional)，该注释还用作文档。例如，@singleton表示该类旨在为线程安全。 @Singleton public class InMemoryTransactionLog implements TransactionLog { /* everything here should be threadsafe! */ } 或者写在被@Provides注解过的方法上 @Provides @Singleton TransactionLog provideTransactionLog() { ... } 2.2 bind bind(TransactionLog.class).to(InMemoryTransactionLog.class).in(Singleton.class); bind()：指定Guice map中的Provider to()：指定bind()中引用的实现类 in()：(这句话建议读原文)接受either a scoping annotation like RequestScoped.class and also Scope instances like ServletScopes.REQUEST:in(RequestScoped.class); in(ServletScopes.REQUEST); 2.3 优先级 bind方法总是最优先的，如果使用注解写的scope不是想要的，可以直接使用bind方法绑定为Scopes.NO_SCOPE。 2.4 接口与实现类 如果1个类同时实现了2个接口，如下： public class Applebees implements Bar,Grill {} 然后在bind时写成如下代码： bind(Bar.class).to(Applebees.class).in(Singleton.class); bind(Grill.class).to(Applebees.class).in(Singleton.class); 这样写会生成两个单例的实例，一个Bar的，一个Grill的，但2个实例其实都是Applebees，因为Guice绑定的bean是源类，即bind()里面的参数，而不是to()里面的参数。 如果只想创建一个实例，把@Singleton写在实现类Applebees上，或者重新bind： bind(Applebees.class).in(Singleton.class); 这样上面的两个绑定的就没必要了，建议删掉。 3 饿汉 singleton 默认情况下，Guice使用懒汉加载单例，但也支持饿汉(Eager)单例： bind(TransactionLog.class).to(InMemoryTransactionLog.class).asEagerSingleton(); 使用枚举变量Stage来区分使用策略： 方法\\Stage PRODUCTION DEVELOPMENT .asEagerSingleton() eager eager .in(Singleton.class) eager lazy .in(Scopes.SINGLETON) eager lazy @Singleton eager* lazy 4 线程安全 被以下注解注解过的类必须是线程安全的： @Singleton @SessionScoped 而@RequestScoped注解过的类不必追求线程安全。 通常被@Singleton和@SessionScoped注解的类中如果依赖@RequestScoped注解过的类是错误的。 5 测试 如果想测试在使用了scope的Guice环境下的方法，却不关心具体的scope，可以使用Scopes.NO_SCOPE（没有scope就意味着使用默认的，即每次请求都是新的实例） import com.google.inject.Scopes; @RunWith(Junit4.class) final class FooTest { static class TestModule extends AbstractModule { @Override protected void configure() { bindScope(BatchScoped.class, Scopes.NO_SCOPE); } } } Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-29 21:41:49 "},"chapter5/":{"url":"chapter5/","title":"Guice bindings","keywords":"","body":"Bindings overview 通过创建一个bind，可以往Guice map中插入一条新的记录entry。 有这么多种bind： Linked Bindings Binding Annotations Instance Bindings @Provides Methods Provider Bindings Untargeted Bindings Constructor Bindings Built-in Bindings Just-In-Time Bindings Multibindings Restricting the Binding Source 这句话不懂： The injector also includes bindings for the providers of its other bindings. Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-29 21:54:13 "},"chapter5/section1/":{"url":"chapter5/section1/","title":"1 Linked Bindings","keywords":"","body":"Linked Bindings 说白了就是将父类交给Guice管理，但是父类的引用指向真正的实现类。 官方说法：Linked bindings map a type to its implementation. 例如： public class BillingModule extends AbstractModule { @Provides TransactionLog provideTransactionLog(DatabaseTransactionLog impl) { return impl; } } 使用injector.getInstance(TransactionLog.class)时，当injector碰到有依赖该bean时，自动会将该bean的实现类赋给该bean，此例则会把DatabaseTransactionLog给TransactionLog。 当然，该方式存在传递性，例如： public class BillingModule extends AbstractModule { @Provides TransactionLog provideTransactionLog(DatabaseTransactionLog databaseTransactionLog) { return databaseTransactionLog; } @Provides DatabaseTransactionLog provideDatabaseTransactionLog(MySqlDatabaseTransactionLog impl) { return impl; } } 使用injector.getInstance(TransactionLog.class)时，会返回MySqlDatabaseTransactionLog。 一样的，除了使用注解方式外，还可以使用bind（在前面的章节中已经大量使用过）。 bind(DatabaseTransactionLog.class).to(MySqlDatabaseTransactionLog.class); Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-29 22:04:26 "},"chapter5/section2/":{"url":"chapter5/section2/","title":"2 Binding Annotations","keywords":"","body":"TreeviewCopyright © qgao 2021-* all right reserved, powered by aleen42 1 含义 2 @Named Binding Annotations 1 含义 说人话就是，有时候可能想要给一个接口注入一个实现类，但是这个接口有两个实现类，但这两个实现类都被放进了容器里，此时就不知道该这个接口注入哪一个实现类了。 在Guice 框架模型(mental modal)中也提到过这个问题，只需要配合@Qualifer或者@BindingAnnotation(java元注解)使用即可，并且应该用在Guice map中的key为Key的对象里。 如下所示例子： package example.pizza; import static java.lang.annotation.ElementType.PARAMETER; import static java.lang.annotation.ElementType.FIELD; import static java.lang.annotation.ElementType.METHOD; import static java.lang.annotation.RetentionPolicy.RUNTIME; import java.lang.annotation.Target; import java.lang.annotation.Retention; import javax.inject.Qualifier; @Qualifier @Target({ FIELD, PARAMETER, METHOD }) @Retention(RUNTIME) public @interface PayPal {} // Older code may still use Guice `BindingAnnotation` in place of the standard // `@Qualifier` annotation. New code should use `@Qualifier` instead. @BindingAnnotation @Target({ FIELD, PARAMETER, METHOD }) @Retention(RUNTIME) public @interface GoogleCheckout {} 这些代码可以像Guice 快速上手写在单独一个java文件里，也可以直接写在使用这个注解的类里。 两种方式创建bindings，bind或@Provide： final class CreditCardProcessorModule extends AbstractModule { @Override protected void configure() { // This uses the optional `annotatedWith` clause in the `bind()` statement bind(CreditCardProcessor.class) .annotatedWith(PayPal.class) .to(PayPalCreditCardProcessor.class); } // This uses binding annotation with a @Provides method @Provides @GoogleCheckout CreditCardProcessor provideCheckoutProcessor( CheckoutCreditCardProcessor processor) { return processor; } } 然后像这样使用： @Inject public RealBillingService(@PayPal CreditCardProcessor processor,TransactionLog transactionLog) { ... } //或者 @Inject public RealBillingService(@GoogleCheckout CreditCardProcessor processor,TransactionLog transactionLog) { ... } 2 @Named 除了上面的方式，还可以使用@Named，它有一个String参数，通过指定具体的String，可以唯一标明一个实例： final class CreditCardProcessorModule extends AbstractModule { @Override protected void configure() { bind(CreditCardProcessor.class) .annotatedWith(Names.named(\"Checkout\")) //只要在依赖时，有注解@Named(\"Checkout\") .to(CheckoutCreditCardProcessor.class); //就给注入CheckoutCreditCardProcessor } } 依赖注入时： @Inject public RealBillingService(@Named(\"Checkout\") CreditCardProcessor processor, TransactionLog transactionLog) { ... } 但是不推荐这种@Named方式(sparingly保守使用)，因为编译器无法check string，最好还是像第1小节一样自定义自己的注解来实现唯一标识。 Copyright © qgao 2021-* all right reserved，powered by Gitbook该文件修订时间： 2022-05-29 22:34:58 "}}